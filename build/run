#!/bin/bash

set -o errexit
set -o xtrace

build_dir="$(dirname $0)"
src_dir="$(realpath ${build_dir}/..)"
sed=$(which gsed || which sed)
GIT_COMMIT=$(git rev-parse HEAD)
GIT_BRANCH=${VERSION:-$(git rev-parse --abbrev-ref HEAD | sed -e 's^/^-^g; s^[.]^-^g;' | sed -e 's/_/-/g' | tr '[:upper:]' '[:lower:]')}
IMAGE=${IMAGE:-"perconalab/percona-postgresql-operator:${GIT_BRANCH}"}
IMAGE=$(echo "$IMAGE" | sed -e 's#percona/#perconalab/#')
STANDALONE_APPS_TO_BUILD=( 'pgo-apiserver' 'pgo-event' 'pgo-rmdata' 'pgo-scheduler' 'postgres-operator' )

usage() {
    echo "Usage:"                                                           1>&2
    echo "    ./run -h                      Display this help message."     1>&2
    echo "    ./run <app_name>              Build one of pg applications:"  1>&2
    echo                                                                    1>&2
    echo "                                                  pgo-apiserver " 1>&2
    echo "                                                  pgo-deployer"   1>&2
    echo "                                                  pgo-event"      1>&2
    echo "                                                  pgo-rmdata"     1>&2
    echo "                                                  pgo-scheduler"  1>&2
    echo "                                                  postgres-operator"  1>&2
}

arg_parse() {
    package=""  # Default to empty package
    target=""  # Default to empty target

    while getopts ":h" opt; do
        case ${opt} in
        h )
            usage
            exit 1
            ;;
        \? )
            echo "Invalid Option: -$OPTARG" 1>&2
            exit 1
            ;;
        esac
    done
    shift $((OPTIND -1))

    subcommand=$1; shift
    case "$subcommand" in
        pgo-apiserver)
            echo 'pgo-apiserver'
            return 0
            ;;
        pgo-deployer)
            echo 'pgo-deployer'
            return 0
            ;;
        pgo-event)
            echo 'pgo-event'
            return 0
            ;;
        pgo-rmdata)
            echo 'pgo-rmdata'
            return 0
            ;;
        pgo-scheduler)
            echo 'pgo-scheduler'
            return 0
            ;;
        postgres-operator)
            echo 'postgres-operator'
            return 0
            ;;
        *)
            usage
            exit 1
            ;;
    esac
}

get_target_tag() {
    if [[ "${1}" == "postgres-operator" ]]; then
        echo ${IMAGE}
    else
        echo "${IMAGE}-${1}"
    fi
}

build_image() {
    local app=${1}
    local tag=${2}
    until docker ps;
        do sleep 1;
    done
    export GO_LDFLAGS="-w -s -trimpath $GO_LDFLAGS"
    pushd ${src_dir}
        docker build \
            --build-arg GIT_COMMIT=$GIT_COMMIT \
            --build-arg GIT_BRANCH=$GIT_BRANCH \
            --build-arg GO_LDFLAGS="$GO_LDFLAGS" \
            --squash \
            --no-cache \
            -t "${tag}" -f build/${app}/Dockerfile .
    popd
    # docker push "${tag}"
}

prepare_n_build() {
    case ${1} in
        pgo-deployer)
            $sed -i.bak 's/tag_prefix.*/tag_prefix:\ "'"${GIT_BRANCH}"'"/g' ${src_dir}/deploy/operator.yml
            ;;
    esac
    build_image ${1} $(get_target_tag ${1})
}

main() {
    local args=$@
    local target_app=''
    export IMAGE

    if [[ -n $* ]]; then    # if app is set, build it
        set +o xtrace
        target_app=$(arg_parse ${args})
        set -o xtrace
        prepare_n_build ${target_app} $(get_target_tag ${target_app})
    else                    # build all apps
        for app in ${STANDALONE_APPS_TO_BUILD[@]}; do
            set +x
            echo
            echo ": Building ${app} image"
            echo
            set -x

            build_image ${app} $(get_target_tag ${app})
        done
        prepare_n_build 'pgo-deployer' $(get_target_tag 'pgo-deployer')
    fi
}

main $@